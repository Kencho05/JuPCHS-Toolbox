# List of functions

## BuildPCHS

    PCHS = BuildPCHS(nx,nu,J,R,H,dH,G,dt,xlabel,ulabel,ylabel,name)
             
Creates a new port-controlled Hamiltonian system

* Inputs:
    * nx (integer): number of state varibles (default = 1)
    * ny (integer): number of inputs (default = 1)
    * J (function or matrix): interconection matrix (default = 0)
    * R (function or matrix): damping matrix (default = 0)
    * H (function or matrix): Hamiltonian (default = 0)
    * dH (function or matrix): Gradient of H (default = 0)
    * G (function or matrix): input matrix (default = 0)
    * dt (Float): discretization time (defaule = 1E-6)
    * xlabel (vector of strings): label for the state variables (default = [x1,x2, ..., xn])
    * ulabel (vector of strings): label for the inputs (default = [u1,u2, ..., um])
    * ylabel (vector of strings): label for the outputs (default = [y1,y2, ..., ym])
    * name (string): name of the PCHS
* Output:
    * (typePCHS) port-controlled Hamiltonian system


## Feedback (*)

- If the input is an integer and a `typePCHS`, the operator applies a **parallel interconnection** repeated the number of times indicated by the integer.

        PCHS3 = PCHS1 * n
        PCHS1 = n * PCHS1

- If both inputs are `typePCHS`, the operator performs a **feedback interconnection**.

        PCHS3 = PCHS1 * PCHS2

- If the inputs are a matrix and a `typePCHS`, the operator applies a **matrix transformation**, where the PCHS input is pre-multiplied by the matrix and the output is post-multiplied by its transpose or using the function `MatrixTransformation`

        PCHS3 = M * PCHS1
        PCHS3 = PCHS1 * M
        PCHS3 = MatrixTransformation(PCHS1,M)


## Parallel (+)

Parallel interconnection of two PCHS

    PCHS3 = PCHS1 + PCHS2

## Simulate

    function Simulate(PCHS,u,xini,nt,method)

 Simulates a port-controlled Hamiltonian system.

 * Inputs: 
    * PCHS (typePCHS): port-controlled Hamiltonian system
    * u (vector or function): input (default = 0)
    * xini (vector): initial conditions (default=0)
    * nt (float): number of points (default=500)
    * method (string): method for solving the differential equation (default = "Euler"). The method can be selected using the following keywords:
        * *"Euler","ForwardEuler"* - Forward Euler
        * *"ImplicitEuler","BackwardEuler","iEuler","iE"* - Midpoint
        * *"RungeKutta","RK"* - Runge Kutta
        * *"trapezoid","Trapezoid","Trapezoidal"* - Trapezoidal
        * *"BackwardDiff","BackwardDiff","BackwardDifferentiation"* - Backward Differentiation Formulas
        * *"Hamilton","Hamiltonian","H"* - Explicit/implicit
 * Output:
    * (DataFrame) DataFrame with time, states, inputs, outputs and Hamiltonian   

 
 
## PlotResults

    function PlotResults(PCHS,data,xscale,graph,xref)

Plot results from a simulated data

* Inputs:
    * PCHS (typePCHS): port-controlled Hamiltonian system
    * data (DataFrame): result from the simulation
    * xscale (vector): scale for the state variables (default=1)
    * (Vector{String}): variables to plot (default = `["x"]`).Allowed entries are: `"x"` (state variables), `"u"` (input), and `"H"` (Hamiltonian). Any combination or subset of these strings can be provided, e.g. `["x","H","u"]`, `["u"]`, `["x","H"]`, etc
    * xref (vector): optional reference for the state variables. The reference is only plotted when this argument is supplied.
* Output: 
    * (plot) basic plot with variables selected.


## Heaviside

    function Heaviside(t)

Heaviside step function.

$\operatorname{Heaviside}(t)=\left\{\begin{array}{cc} 
1, & t>0 \\
0, & t\leq 0
\end{array}\right\}$ 


## AdmissibleEquilibrium

    function AdmissibleEquilibrium(PCHS,u,x)


Identify if $x,u$ is an admissible equilibrium for PCHS.  If u or x are empty, then the function assumes a vector of zeros.  

* Inputs:  
    * PCHS (typePCHS):  port-controlled Hamiltonian system
    * u (vector): input (default = 0)
    * x (vector): states (default = 0)
* Output:
    * (boolean) True if (x,u) is an admissible equilibrium point  

## Hmin

    function Hmin(PCHS,xini,method,all,alpha,tol,max_iter)

find the minimum of the Hamiltonian $H

* Inputs:
    * PCHS (typePCHS): port-controllend Hamiltonian system
    * xini (vector): initial point for the gradient method (default xini = 0)
    * method (string): method for solving the optimization problem (default = "newton"). The method can be selected using the following keywords:
        * *"nonlinear gradient", "nonlinear conjugate gradient"* - No-nlinear conjugate gradient
        * *"gradient", "Gradient"* - Gradient
        * *"fixed gradient", "Fixed Gradient"* - Fixed Gradient
        * *"elipsoid", "Elipsoid"* - Elipsoid
        * *"newton", "Newton"* - Newton
    * all (boolean): flag to display the convergence plot including all available methods (default = false).
    * alpha (float): step size used in the fixed‚Äìgradient method (default = 0.1).
    * tol (float): tolerance threshold employed by each method (default = 1E-6).
    * max_iter (float): maximum number of iterations allowed during the convergence process (default = 500).
* Output: 
    * x_opt (float): optimal solution obtained by the selected method.
    * hm (float): value of the Hamiltonian at the optimal point.
    * (plot) graphical visualization of the convergence process.


## Equilibrium point

    function equilibrium_point(PCHS,xini,uini,xd,ud,method,tol,max_iter)

find the equilibrium point of the system

* Inputs:
    * PCHS (typePCHS): port-controllend Hamiltonian system.
    * xini (vector): initial point for the gradient method (default xini = 0).
    * uini (vector): initial point for the input (default xini = 0).
    * xd (vector): desired state for equilibrium verification (default xd = 0).
    * ud (vector): desired input for equilibrium verification (default ud = 0).
    * method (string): method for solving the optimization problem (default = "newton"). The method can be selected using the following keywords:
        * *"fixed point", "Fixed Point"* - Fixed point
        * *"newton", "Newton"* - Newton
    * tol (float): tolerance threshold employed by each method (default = 1E-6).
    * max_iter (float): maximum number of iterations allowed during the convergence process (default = 500).
* Output: 
    * x_opt (float): optimal state obtained from the optimization process.
    * u_opt (float): optimal input associated with the computed equilibrium.

## Lipschitz 

    function islipschitz(f,inf,sup,nx,nt,tol)

find out if the function is Lipschitz and compute its constant

* Inputs:
    * f (function): function to be checked for Lipschitz continuity.
    * inf (float): lower bound of the interval where the function will be tested (default = -100).
    * sup (float): upper bound of the interval where the function will be tested (default = 100).
    * nx (int): number of state variables.
    * nt (int): number of random samples to generate (default = 500).
    * tol (float): numerical tolerance used during the verification (dafault = 0.01).
* Output: 
    * L (float): estimated Lipschitz constant. If the function is not Lipschitz within the given range, the value returned is **0**.


## Content

* [Defining PCHS](CH01.md)
* [Interconnecting PHCS](CH02.md)
* [Simulating for PCHS](CH03.md)
* [Analyzing for PCHS](CH04.md)
* [Examples](CH05.md)
* [List of functions](CH06.md)

---
Back: [Introduction](INTRO.md)

---
üè† [Proyect root](https://github.com/Kencho05/JuPCHS-Toolbox)